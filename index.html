<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suite de Análisis de Dominios</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <style>
        body { font-family: 'Inter', sans-serif; scroll-behavior: smooth; }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6;
            border-radius: 50%; width: 24px; height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .check-label { transition: all 0.2s ease-in-out; }
        .check-label:hover { background-color: #f9fafb; }
        .result-item .label { min-width: 140px; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="w-full max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8 my-8">
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Internet Society Uruguay (Mediciones ISOC-LAC)</h1>
            <p class="text-gray-500 mt-2">Proyecto colaborativo de capítulos de Internet Society para mediciones abiertas de la región LAC.</p>
            <button id="aboutBtn" class="text-blue-600 underline text-sm mt-2">Acerca de</button>
            <div id="aboutText" class="hidden mt-4 text-sm text-gray-700">
                El Capítulo Uruguay de Internet Society, junto a otros capítulos de la región,
                desarrolló esta herramienta abierta para medir la adopción de tecnologías y buenas prácticas
                en América Latina y el Caribe. Esta plataforma se integrará con ISOC Pulse para
                recopilar y compartir información regional.
            </div>
        </div>

        <div class="mb-6">
            <label for="countrySelect" class="block text-sm font-medium text-gray-700 mb-2">Selecciona un país</label>
            <select id="countrySelect" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition">
                <option value="" selected disabled>-- País --</option>
            </select>
        </div>

        <div class="mb-6">
            <label for="domains" class="block text-sm font-medium text-gray-700 mb-2">Dominios (separados por coma)</label>
            <textarea id="domains" rows="3" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="google.com, nic.uy, lacnic.net"></textarea>
        </div>

        <div class="mb-6">
            <div class="flex justify-between items-center mb-3">
                <label class="block text-sm font-medium text-gray-700">Verificaciones a realizar</label>
                <button id="selectAll" type="button" class="text-blue-600 text-sm">Seleccionar todos</button>
            </div>
            <div id="checksContainer" class="space-y-4"></div>
        </div>

        <div class="flex flex-col items-center justify-center">
            <button id="checkButton" class="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-transform transform hover:scale-105 flex items-center justify-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M9 9a2 2 0 114 0 2 2 0 01-4 0z" /><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.414l2.26-2.26a4 4 0 10-1.15-7.446z" clip-rule="evenodd" /></svg>
                <span>Analizar Dominios</span>
            </button>
            <div class="flex space-x-4 mt-4">
                <button id="historyButton" class="bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500">Ver Historial</button>
                <button id="clearHistoryButton" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400">Limpiar Historial</button>
            </div>
        </div>

        <div id="history" class="mt-6 hidden"></div>
        <div id="map" class="w-full h-64 mb-8 hidden"></div>
        <div id="results-container" class="mt-8">
            <div id="loader" class="hidden items-center justify-center py-4">
                <div class="loader"></div><p class="ml-3 text-gray-600">Analizando...</p>
            </div>
            <div id="results" class="space-y-6"></div>
        </div>
    </div>

<script>
    const checkButton = document.getElementById('checkButton');
    const domainsInput = document.getElementById('domains');
    const countrySelect = document.getElementById('countrySelect');
    const resultsContainer = document.getElementById('results');
    const loader = document.getElementById('loader');
    const checksContainer = document.getElementById('checksContainer');
    let checkboxes = [];
    const selectAllBtn = document.getElementById('selectAll');
    const historyButton = document.getElementById('historyButton');
    const clearHistoryButton = document.getElementById('clearHistoryButton');
    const historyDiv = document.getElementById('history');
    const aboutBtn = document.getElementById('aboutBtn');
    const aboutText = document.getElementById('aboutText');
    const mapDiv = document.getElementById('map');
    let map; let mapMarkers = [];
        const API_BASE = 'http://localhost:3000';
    const headerCache = {};
    const tlsCache = {};

    const countryTlds = {
        'Uruguay': ['uy','com.uy','edu.uy','gub.uy','org.uy','net.uy','mil.uy','destinosnaturales.gub.uy','agesic.gub.uy'],
        'Argentina': ['ar','com.ar','gob.ar','edu.ar','org.ar','net.ar'],
        'Brasil': ['br','com.br','gov.br','edu.br','org.br','net.br'],
        'Ecuador': ['ec','com.ec','gob.ec','edu.ec','org.ec','net.ec'],
        'Bolivia': ['bo','com.bo','gob.bo','edu.bo','org.bo','net.bo'],
        'Chile': ['cl','com.cl','gob.cl','edu.cl','org.cl','net.cl'],
        'Paraguay': ['py','com.py','gov.py','edu.py','org.py','net.py'],
        'Perú': ['pe','com.pe','gob.pe','edu.pe','org.pe','net.pe'],
        'Colombia': ['co','com.co','gov.co','edu.co','org.co','net.co'],
        'México': ['mx','com.mx','gob.mx','edu.mx','org.mx','net.mx']
    };

    for (const country of Object.keys(countryTlds)) {
        const opt = document.createElement('option');
        opt.value = country;
        opt.textContent = country;
        countrySelect.appendChild(opt);
    }

    countrySelect.addEventListener('change', () => {
        const domains = countryTlds[countrySelect.value] || [];
        domainsInput.value = domains.join(', ');
    });

    aboutBtn.addEventListener('click', () => {
        aboutText.classList.toggle('hidden');
    });

    function initMap() {
        map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
    }
    initMap();

    function clearMap() {
        mapMarkers.forEach(m => map.removeLayer(m));
        mapMarkers = [];
    }

    async function updateMap(domains) {
        if (!domains.length) return;
        clearMap();
        map.invalidateSize();
        let hasMarker = false;
        for (const d of domains) {
            try {
                const ascii = toASCII(d);
                const data = await fetchWithTimeout(`${API_BASE}/serverlocation/${ascii}`);
                if (data.error) continue;
                const locations = data.locations || [];
                locations
                    .filter(loc => typeof loc.latitude === 'number' && typeof loc.longitude === 'number')
                    .forEach(loc => {
                        const textParts = [d];
                        if (loc.country) textParts.push(loc.country);
                        if (loc.city) textParts.push(loc.city);
                        const marker = L.marker([loc.latitude, loc.longitude])
                            .addTo(map)
                            .bindPopup(textParts.join(' - '));
                        mapMarkers.push(marker);
                        hasMarker = true;
                    });
            } catch (e) {}
        }
        if (hasMarker) {
            mapDiv.classList.remove('hidden');
            map.setView([0, 0], 2);
        } else {
            mapDiv.classList.add('hidden');
        }
    }

    const checkGroups = {
        network: 'Infraestructura y Red',
        email: 'Correo y DNS',
        security: 'Seguridad y Certificados',
        web: 'Sitio Web y Contenido',
        status: 'Estado y Rendimiento',
        intel: 'Inteligencia y Reputación'
    };

    const checkConfig = {
        ipinfo: { label: 'More IP Info', group: 'network' },
        serverlocation: { label: 'Server Location', group: 'network' },
        dnsrecords: { label: 'DNS Records', group: 'network' },
        dnssec: { label: 'DNSSEC', group: 'network', default: true },
        dnssecurity: { label: 'DNS Security Extensions', group: 'network' },
        ipv4: { label: 'IPv4', group: 'network', default: true },
        ipv6: { label: 'IPv6', group: 'network', default: true },
        asn: { label: 'ASN', group: 'network', default: true },
        rpki: { label: 'RPKI', group: 'network' },
        associated: { label: 'Associated Hosts', group: 'network' },
        traceroute: { label: 'Traceroute', group: 'network' },
        dnsserver: { label: 'DNS Server', group: 'network' },
        txt: { label: 'TXT Records', group: 'network' },
        openports: { label: 'Open Ports', group: 'network' },
        serverinfo: { label: 'Server Info', group: 'network' },

        emailconfig: { label: 'Email Configuration', group: 'email' },
        dmarc: { label: 'DMARC', group: 'email', default: true },
        spf: { label: 'SPF', group: 'email', default: true },
        dkim: { label: 'DKIM', group: 'email' },
        mx: { label: 'MX', group: 'email' },
        smtputf8: { label: 'SMTPUTF8', group: 'email' },

        sslchain: { label: 'SSL Chain info', group: 'security' },
        https: { label: 'HTTPS', group: 'security' },
        redirect: { label: 'Redir. HTTPS', group: 'security' },
        redirectchain: { label: 'Redirect Chain', group: 'security' },
        hsts: { label: 'HTTP Strict Transport Security', group: 'security' },
        httpsecurity: { label: 'HTTP Security Features', group: 'security' },
        csp: { label: 'CSP', group: 'security' },
        xfo: { label: 'X-Frame-Options', group: 'security' },
        xcto: { label: 'X-Content-Type', group: 'security' },
        referrer: { label: 'Referrer-Policy', group: 'security' },
        permissions: { label: 'Permissions-Policy', group: 'security' },
        xxss: { label: 'X-XSS-Protection', group: 'security' },
        server: { label: 'Encabezado Server', group: 'security' },
        compression: { label: 'Compresión HTTP', group: 'security' },
        ocsp: { label: 'OCSP Stapling', group: 'security' },
        tls: { label: 'Versión TLS', group: 'security' },
        key: { label: 'Intercambio de Clave', group: 'security' },
        tlsciphers: { label: 'TLS Cipher Suites', group: 'security' },
        tlsconfig: { label: 'TLS Security Config', group: 'security' },
        tlshandshake: { label: 'TLS Handshake Simulation', group: 'security' },
        firewall: { label: 'Firewall Detection', group: 'security' },
        block: { label: 'Block Detection', group: 'security' },
        malware: { label: 'Malware & Phishing Detection', group: 'security' },
        caa: { label: 'CAA', group: 'security' },
        tlsa: { label: 'TLSA', group: 'security' },

        cookies: { label: 'Cookies', group: 'web' },
        allheaders: { label: 'Headers', group: 'web' },
        sitefeatures: { label: 'Site Features', group: 'web' },
        linkedpages: { label: 'Linked Pages', group: 'web' },
        listedpages: { label: 'Listed Pages', group: 'web' },
        crawl: { label: 'Crawl Rules', group: 'web' },
        w3c: { label: 'W3C', group: 'web' },
        quality: { label: 'Quality Metrics', group: 'web' },
        techstack: { label: 'Tech Stack', group: 'web' },
        socialtags: { label: 'Social Tags', group: 'web' },
        screenshot: { label: 'Screenshot', group: 'web' },

        serverstatus: { label: 'Server Status', group: 'status' },
        carbon: { label: 'Carbon Footprint', group: 'status' },

        whois: { label: 'Whois Lookup', group: 'intel' },
        domaininfo: { label: 'Domain Info', group: 'intel' },
        securitytxt: { label: 'Security.txt', group: 'intel' },
        archive: { label: 'Archive History', group: 'intel' },
        globalrank: { label: 'Global Ranking', group: 'intel' }
    };

    const groupOrder = ['network', 'email', 'security', 'web', 'status', 'intel'];

    function renderChecks() {
        checksContainer.innerHTML = '';
        groupOrder.forEach(groupKey => {
            const title = checkGroups[groupKey];
            if (!title) return;
            const entries = Object.entries(checkConfig).filter(([, cfg]) => cfg.group === groupKey);
            if (!entries.length) return;
            const section = document.createElement('div');
            section.className = 'border border-gray-200 rounded-lg';
            const heading = document.createElement('div');
            heading.className = 'px-3 py-2 bg-gray-100 text-sm font-semibold text-gray-700';
            heading.textContent = title;
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2 p-3';
            entries.forEach(([key, cfg]) => {
                const label = document.createElement('label');
                label.className = 'check-label flex items-center p-2 border rounded-lg cursor-pointer hover:bg-gray-50';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.dataset.check = key;
                input.className = 'h-4 w-4 rounded';
                input.checked = Boolean(cfg.default);
                const span = document.createElement('span');
                span.className = 'ml-2 text-sm';
                span.textContent = cfg.label;
                label.appendChild(input);
                label.appendChild(span);
                grid.appendChild(label);
            });
            section.appendChild(heading);
            section.appendChild(grid);
            checksContainer.appendChild(section);
        });
        checkboxes = document.querySelectorAll('input[type="checkbox"][data-check]');
    }

    renderChecks();

    function loadHistory() {
        const history = JSON.parse(localStorage.getItem('domainHistory') || '[]');
        if (!history.length) {
            historyDiv.innerHTML = '<div class="text-center text-gray-500">Sin historial</div>';
            return;
        }
        let html = '';
        history.forEach(entry => {
            html += `<div class="mb-4"><h4 class="font-semibold mb-2">${entry.date}</h4>`;
            html += '<div class="overflow-auto"><table class="min-w-full text-sm border"><thead><tr><th class="border px-2 py-1">Dominio</th>';
            entry.checks.forEach(c => { html += `<th class="border px-2 py-1">${checkConfig[c]?.label || c}</th>`; });
            html += '</tr></thead><tbody>';
            entry.domains.forEach(d => {
                html += `<tr><td class="border px-2 py-1">${d.domain}</td>`;
                entry.checks.forEach(c => {
                    const val = d.results[c]?.status || '-';
                    html += `<td class="border px-2 py-1 text-center">${val}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table></div></div>';
        });
        historyDiv.innerHTML = html;
    }

    function saveHistory(entry) {
        const history = JSON.parse(localStorage.getItem('domainHistory') || '[]');
        history.push(entry);
        localStorage.setItem('domainHistory', JSON.stringify(history));
    }

    function toASCII(domain) {
        try { return new URL('http://' + domain).hostname; }
        catch (e) { return domain; }
    }

    async function fetchWithTimeout(resource, options = {}, timeout = 20000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        try {
            const response = await fetch(resource, { ...options, signal: controller.signal });
            clearTimeout(id);
            if (!response.ok) throw new Error('Servicio no disponible');
            return response.json();
        } catch (error) {
            clearTimeout(id);
            throw new Error(error.name === 'AbortError' ? 'Timeout' : 'Servicio no disponible');
        }
    }

    async function getSecurityHeaders(domain) {
        const ascii = toASCII(domain);
        if (headerCache[ascii]) return headerCache[ascii];
        const data = await fetchWithTimeout(`${API_BASE}/headers/${ascii}`);
        headerCache[ascii] = data;
        return data;
    }

    async function getTlsInfo(domain) {
        const ascii = toASCII(domain);
        if (tlsCache[ascii]) return tlsCache[ascii];
        const data = await fetchWithTimeout(`${API_BASE}/tlsinfo/${ascii}`);
        tlsCache[ascii] = data;
        return data;
    }

    function getStatusHtml(status, details = '') {
        let icon, color, text;
        switch (status) {
            case 'ok':
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-green-600'; text = details; break;
            case 'fail':
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-red-600'; text = details; break;
            case 'error':
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-gray-500'; text = details; break;
            default:
                icon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
                color = 'text-yellow-600'; text = details; break;
        }
        return `<div class="flex items-center ${color}"><span class="mr-2 flex-shrink-0">${icon}</span><span class="font-semibold text-sm">${text}</span></div>`;
    }

    function createResultCard(domain, selectedChecks) {
        const card = document.createElement('div');
        card.className = 'p-4 rounded-lg bg-gray-50 border border-gray-200 shadow-sm';
        const title = document.createElement('h3');
        title.className = 'font-bold text-xl text-gray-800 mb-4 pb-2 border-b';
        title.textContent = domain;
        card.appendChild(title);

        const placeholders = {};
        groupOrder.forEach(groupKey => {
            const filtered = selectedChecks.filter(c => checkConfig[c]?.group === groupKey);
            if (!filtered.length) return;
            const h4 = document.createElement('h4');
            h4.className = 'text-md font-semibold text-gray-700 mt-4 mb-2';
            h4.textContent = checkGroups[groupKey];
            card.appendChild(h4);
            filtered.forEach(c => {
                const row = document.createElement('div');
                row.className = 'result-item flex justify-between items-center py-2 border-b border-gray-200 last:border-b-0';
                const label = document.createElement('span');
                label.className = 'label text-sm font-medium text-gray-600';
                label.textContent = checkConfig[c].label;
                const placeholder = document.createElement('span');
                placeholder.className = 'text-gray-500 flex items-center';
                placeholder.innerHTML = '<div class="loader mr-2"></div><span>Cargando...</span>';
                row.appendChild(label);
                row.appendChild(placeholder);
                card.appendChild(row);
                placeholders[c] = placeholder;
            });
        });

        resultsContainer.appendChild(card);
        return placeholders;
    }

    async function getCheckResult(checkType, domain) {
        const { label } = checkConfig[checkType];
        const ascii = toASCII(domain);
        try {
            switch (checkType) {
                case 'dnssec': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnssec/${ascii}`);
                    const ok = data.valid;
                    const details = ok
                        ? (data.algorithms?.length ? `Algoritmos: ${data.algorithms.join(', ')}` : 'DNSSEC configurado')
                        : '¡No tiene DNSSEC!';
                    return { label, status: ok ? 'ok' : 'fail', details };
                }
                case 'ipv4': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=${ascii}&type=A`);
                    const ips = data.Answer?.filter(r => r.type === 1).map(r => r.data) || [];
                    const geos = [];
                    for (const ip of ips) {
                        try {
                            const info = await fetchWithTimeout(`https://ipapi.co/${ip}/json/`);
                            geos.push({ ip, country: info.country_name, lat: info.latitude, lon: info.longitude, asn: info.asn });
                        } catch (e) {}
                    }
                    const details = ips.length ? ips.join(', ') : 'No tiene IPv4';
                    return { label, status: ips.length ? 'ok' : 'fail', details, geos };
                }
                case 'ipv6': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=${ascii}&type=AAAA`);
                    const ips = data.Answer?.filter(r => r.type === 28).map(r => r.data) || [];
                    return { label, status: ips.length ? 'ok' : 'fail', details: ips.length ? ips.join(', ') : 'No tiene IPv6' };
                }
                case 'asn': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=${ascii}&type=A`);
                    const ip = data.Answer?.find(r => r.type === 1)?.data;
                    if (!ip) return { label, status: 'fail', details: 'Sin IPv4' };
                    const info = await fetchWithTimeout(`https://ipapi.co/${ip}/json/`);
                    return { label, status: info.asn ? 'ok' : 'fail', details: info.asn || 'Sin datos' };
                }
                case 'dmarc': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=_dmarc.${ascii}&type=TXT`);
                    const found = data.Answer?.some(r => r.data.includes("v=DMARC1"));
                    return { label, status: found ? 'ok' : 'fail', details: found ? 'Política encontrada' : 'No permite DMARC' };
                }
                case 'spf': {
                    const data = await fetchWithTimeout(`https://dns.google/resolve?name=${ascii}&type=TXT`);
                    const found = data.Answer?.some(r => r.data.includes("v=spf1"));
                    return { label, status: found ? 'ok' : 'fail', details: found ? 'Registro encontrado' : 'No permite SPF' };
                }
                case 'dkim': {
                    const data = await fetchWithTimeout(`${API_BASE}/dkim/${ascii}?selector=default`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.found ? 'ok' : 'fail', details: data.found ? 'Registro encontrado' : 'No permite DKIM' };
                }
                case 'mx': {
                    const data = await fetchWithTimeout(`${API_BASE}/mx/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const details = data.records?.map(r => `${r.exchange} (p${r.priority})`).join(', ') || 'No permite MX';
                    return { label, status: data.records?.length ? 'ok' : 'fail', details };
                }
                case 'smtputf8': {
                    const data = await fetchWithTimeout(`${API_BASE}/smtputf8/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const details = data.results?.map(r => {
                        switch (r.status) {
                            case 'supports': return `${r.server}: sí`;
                            case 'no': return `${r.server}: no`;
                            case 'timeout': return `${r.server}: timeout`;
                            case 'connection-error': return `${r.server}: sin conexión`;
                            default: return `${r.server}: sin datos`;
                        }
                    }).join('; ') || 'No permite SMTPUTF8';
                    const ok = data.results?.length && data.results.every(r => r.status === 'supports');
                    return { label, status: ok ? 'ok' : 'fail', details };
                }
                case 'rpki': {
                    const data = await fetchWithTimeout(`${API_BASE}/rpki/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    if (!data.results?.length) return { label, status: 'error', details: 'Sin datos' };
                    const details = data.results.map(r => {
                        const state = r.state === 'valid' ? 'válido' : r.state === 'invalid' ? 'inválido' : 'desconocido';
                        return `${r.ip}: ${state}${r.asn ? ' AS' + r.asn : ''}`;
                    }).join('; ');
                    let status = 'error';
                    if (data.results.some(r => r.state === 'valid')) status = 'ok';
                    else if (data.results.some(r => r.state === 'invalid')) status = 'fail';
                    return { label, status, details };
                }
                case 'whois': {
                    const data = await fetchWithTimeout(`${API_BASE}/whois/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const details = data.country ? `${data.name || 'Desconocido'} (${data.country})` : (data.name || 'Desconocido');
                    return { label, status: data.name ? 'ok' : 'fail', details };
                }
                case 'w3c': {
                    const data = await fetchWithTimeout(`${API_BASE}/w3c/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const details = `${data.errors} errores, ${data.warnings} advertencias`;
                    return { label, status: data.errors === 0 ? 'ok' : 'fail', details };
                }
                case 'sslchain': {
                    const data = await fetchWithTimeout(`${API_BASE}/sslchain/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const chain = data.chain || [];
                    const details = chain
                        .map(cert => `${cert.subject?.CN || cert.subject?.commonName || 'Certificado'} → ${cert.issuer?.CN || cert.issuer?.commonName || 'Emisor desconocido'} (${cert.valid_to || ''})`)
                        .join('<br>');
                    return {
                        label,
                        status: chain.length ? 'ok' : 'fail',
                        details: details || 'Sin certificados'
                    };
                }
                case 'https': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.https ? 'ok' : 'fail', details: data.https ? 'Accesible' : 'No responde HTTPS' };
                }
                case 'redirect': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.redirect ? 'ok' : 'fail', details: data.redirect ? 'Redirige a HTTPS' : 'No redirige' };
                }
                case 'hsts': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.hsts ? 'ok' : 'fail', details: data.hsts ? 'Cabecera presente' : 'Sin HSTS' };
                }
                case 'csp': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.csp ? 'ok' : 'fail', details: data.csp ? 'Cabecera presente' : 'Sin CSP' };
                }
                case 'xfo': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.xfo ? 'ok' : 'fail', details: data.xfo ? 'Cabecera presente' : 'Sin X-Frame-Options' };
                }
                case 'xcto': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.xcto ? 'ok' : 'fail', details: data.xcto ? 'Cabecera presente' : 'Sin X-Content-Type-Options' };
                }
                case 'referrer': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.referrer ? 'ok' : 'fail', details: data.referrer ? 'Cabecera presente' : 'Sin Referrer-Policy' };
                }
                case 'permissions': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.permissions ? 'ok' : 'fail', details: data.permissions ? 'Cabecera presente' : 'Sin Permissions-Policy' };
                }
                case 'xxss': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.xxss ? 'ok' : 'fail', details: data.xxss ? 'Cabecera presente' : 'Sin X-XSS-Protection' };
                }
                case 'server': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.server ? 'fail' : 'ok', details: data.server || 'No expuesto' };
                }
                case 'compression': {
                    const data = await getSecurityHeaders(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.compression ? 'ok' : 'fail', details: data.compression ? 'Compresión habilitada' : 'Sin compresión' };
                }
                case 'ocsp': {
                    const data = await getTlsInfo(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.ocsp ? 'ok' : 'fail', details: data.ocsp ? 'OCSP válido' : 'Sin OCSP' };
                }
                case 'tls': {
                    const data = await getTlsInfo(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const ok = data.protocol === 'TLSv1.3' || data.protocol === 'TLSv1.2';
                    return { label, status: ok ? 'ok' : 'fail', details: data.protocol || 'Desconocido' };
                }
                case 'key': {
                    const data = await getTlsInfo(domain);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const info = data.key || {};
                    let ok = false;
                    if (info.type === 'ECDH') ok = info.size >= 224;
                    else if (info.type === 'DH') ok = info.size >= 2048;
                    else ok = true;
                    const details = info.type ? `${info.type}${info.size ? ' ' + info.size : ''}` : 'Sin datos';
                    return { label, status: ok ? 'ok' : 'fail', details };
                }
                case 'caa': {
                    const data = await fetchWithTimeout(`${API_BASE}/caa/${domain}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.records?.length ? 'ok' : 'fail', details: data.records?.length ? data.records.join(', ') : 'No tiene CAA' };
                }
                case 'tlsa': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlsa/${domain}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.records?.length ? 'ok' : 'fail', details: data.records?.length ? data.records.join(', ') : 'No tiene TLSA' };
                }
                case 'securitytxt': {
                    const data = await fetchWithTimeout(`${API_BASE}/securitytxt/${domain}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return { label, status: data.found ? 'ok' : 'fail', details: data.found ? 'Encontrado' : 'No disponible' };
                }
                case 'ipinfo': {
                    const data = await fetchWithTimeout(`${API_BASE}/ipinfo/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const items = data.details?.map(d => {
                        const location = [d.country, d.city].filter(Boolean).join(' - ');
                        const asn = d.asn ? ` ${d.asn}` : '';
                        return `${d.ip}${location ? ` (${location})` : ''}${asn}`;
                    }) || [];
                    return {
                        label,
                        status: items.length ? 'ok' : 'fail',
                        details: items.length ? items.join('; ') : 'Sin información'
                    };
                }
                case 'serverlocation': {
                    const data = await fetchWithTimeout(`${API_BASE}/serverlocation/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const items = data.locations?.map(loc => {
                        const parts = [loc.country, loc.region, loc.city].filter(Boolean);
                        return `${loc.ip}${parts.length ? ` (${parts.join(' - ')})` : ''}`;
                    }) || [];
                    return {
                        label,
                        status: items.length ? 'ok' : 'fail',
                        details: items.length ? items.join('; ') : 'Sin datos de ubicación'
                    };
                }
                case 'dnsrecords': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnsrecords/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const entries = Object.entries(data.records || {});
                    const summary = entries
                        .filter(([, value]) => Array.isArray(value) ? value.length : value)
                        .map(([type, value]) => {
                            if (Array.isArray(value)) return `${type}: ${value.length}`;
                            if (value && typeof value === 'object' && !Array.isArray(value)) return `${type}: 1`;
                            return `${type}: 0`;
                        });
                    const ok = summary.some(s => !s.endsWith(': 0'));
                    return {
                        label,
                        status: ok ? 'ok' : 'fail',
                        details: summary.length ? summary.join(', ') : 'Sin registros'
                    };
                }
                case 'dnssecurity': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnssecurity/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const secure = data.secure ? 'DNSSEC válido' : 'Sin DNSSEC válido';
                    const doh = data.doh ? 'DoH disponible' : 'DoH no detectado';
                    return {
                        label,
                        status: data.secure ? 'ok' : 'fail',
                        details: `${secure}; ${doh}`
                    };
                }
                case 'associated': {
                    const data = await fetchWithTimeout(`${API_BASE}/associated/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const mapping = data.mapping || [];
                    const info = mapping
                        .map(m => `${m.ip}: ${m.hosts && m.hosts.length ? m.hosts.slice(0, 5).join(', ') : 'Sin dominios'}`)
                        .join('; ');
                    const hasHosts = mapping.some(m => m.hosts && m.hosts.length);
                    return { label, status: hasHosts ? 'ok' : 'fail', details: info || 'Sin datos' };
                }
                case 'redirectchain': {
                    const data = await fetchWithTimeout(`${API_BASE}/redirects/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const chain = data.chain || [];
                    const details = chain
                        .map(step => `${step.statusCode || '-'} → ${step.url}`)
                        .join('<br>');
                    return {
                        label,
                        status: chain.length ? 'ok' : 'fail',
                        details: details || 'Sin redirecciones'
                    };
                }
                case 'txt': {
                    const data = await fetchWithTimeout(`${API_BASE}/txt/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const records = data.records || [];
                    return {
                        label,
                        status: records.length ? 'ok' : 'fail',
                        details: records.length ? records.join('<br>') : 'Sin TXT'
                    };
                }
                case 'cookies': {
                    const data = await fetchWithTimeout(`${API_BASE}/cookies/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const cookies = data.cookies || [];
                    return {
                        label,
                        status: 'ok',
                        details: cookies.length ? cookies.join('<br>') : 'Sin cookies establecidas'
                    };
                }
                case 'crawl': {
                    const data = await fetchWithTimeout(`${API_BASE}/crawl/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: data.content ? 'ok' : 'fail',
                        details: data.content ? data.content.substring(0, 200) + (data.content.length > 200 ? '…' : '') : 'robots.txt no disponible'
                    };
                }
                case 'allheaders': {
                    const data = await fetchWithTimeout(`${API_BASE}/allheaders/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const headers = data.headers || {};
                    const entries = Object.keys(headers)
                        .slice(0, 10)
                        .map(k => `${k}: ${headers[k]}`)
                        .join('<br>');
                    return {
                        label,
                        status: 'ok',
                        details: entries || 'Sin encabezados'
                    };
                }
                case 'quality': {
                    const data = await fetchWithTimeout(`${API_BASE}/quality/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const metrics = data.metrics || [];
                    const details = metrics
                        .map(m => `${m.title || m.id}: ${m.score !== null ? m.score : 'N/D'}`)
                        .join(', ');
                    return { label, status: metrics.length ? 'ok' : 'fail', details: details || 'Sin métricas' };
                }
                case 'techstack': {
                    const data = await fetchWithTimeout(`${API_BASE}/techstack/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const stack = data.stack || [];
                    return {
                        label,
                        status: stack.length ? 'ok' : 'fail',
                        details: stack.length ? stack.join(', ') : 'No detectado'
                    };
                }
                case 'sitefeatures': {
                    const data = await fetchWithTimeout(`${API_BASE}/sitefeatures/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const features = Object.entries(data.features || {})
                        .map(([key, value]) => `${key}: ${value ? 'sí' : 'no'}`)
                        .join(', ');
                    return { label, status: features ? 'ok' : 'fail', details: features || 'Sin datos' };
                }
                case 'linkedpages': {
                    const data = await fetchWithTimeout(`${API_BASE}/linkedpages/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const links = data.links || [];
                    const details = links.slice(0, 10).join('<br>');
                    return {
                        label,
                        status: links.length ? 'ok' : 'fail',
                        details: links.length ? details : 'Sin enlaces'
                    };
                }
                case 'listedpages': {
                    const data = await fetchWithTimeout(`${API_BASE}/listedpages/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const pages = data.pages || [];
                    return {
                        label,
                        status: pages.length ? 'ok' : 'fail',
                        details: pages.length ? pages.slice(0, 10).join('<br>') : 'Sin sitemap'
                    };
                }
                case 'socialtags': {
                    const data = await fetchWithTimeout(`${API_BASE}/socialtags/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const tags = Object.entries(data.tags || {})
                        .slice(0, 10)
                        .map(([k, v]) => `${k}: ${v}`)
                        .join('<br>');
                    return { label, status: tags ? 'ok' : 'fail', details: tags || 'Sin etiquetas sociales' };
                }
                case 'serverstatus': {
                    const data = await fetchWithTimeout(`${API_BASE}/serverstatus/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const statusCode = data.statusCode || data.status || '-';
                    const latency = typeof data.latency === 'number' ? `${data.latency} ms` : 'N/D';
                    const ok = statusCode && Number(statusCode) < 400;
                    return {
                        label,
                        status: ok ? 'ok' : 'fail',
                        details: `Estado ${statusCode} (${latency})`
                    };
                }
                case 'openports': {
                    const data = await fetchWithTimeout(`${API_BASE}/openports/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const ports = (data.ports || []).filter(p => p.status === 'open').map(p => p.port);
                    const details = ports.length ? `Abiertos: ${ports.join(', ')}` : 'Sin puertos comunes abiertos';
                    return { label, status: 'ok', details };
                }
                case 'traceroute': {
                    const data = await fetchWithTimeout(`${API_BASE}/traceroute/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: data.trace ? 'ok' : 'fail',
                        details: data.trace ? data.trace.replace(/\n/g, '<br>') : 'Sin datos'
                    };
                }
                case 'carbon': {
                    const data = await fetchWithTimeout(`${API_BASE}/carbon/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const footprint = data.data?.statistics?.co2?.grid?.grams;
                    const details = typeof footprint === 'number'
                        ? `${footprint.toFixed(2)} g CO₂ por vista`
                        : 'Sin datos de huella';
                    return { label, status: footprint ? 'ok' : 'fail', details };
                }
                case 'serverinfo': {
                    const data = await fetchWithTimeout(`${API_BASE}/serverinfo/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const ips = (data.details || []).map(d => `${d.ip}${d.asn ? ' ' + d.asn : ''}`).join(', ');
                    const info = `${data.server ? `Servidor: ${data.server}. ` : ''}${ips ? `IPs: ${ips}` : ''}`.trim();
                    return { label, status: info ? 'ok' : 'fail', details: info || 'Sin información' };
                }
                case 'dnsserver': {
                    const data = await fetchWithTimeout(`${API_BASE}/dnsserver/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const servers = data.servers || [];
                    return {
                        label,
                        status: servers.length ? 'ok' : 'fail',
                        details: servers.length ? servers.join(', ') : 'Sin servidores autoritativos'
                    };
                }
                case 'domaininfo': {
                    const data = await fetchWithTimeout(`${API_BASE}/domaininfo/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const events = (data.events || [])
                        .map(e => `${e.action}: ${new Date(e.date).toLocaleDateString()}`)
                        .join('<br>');
                    const details = `${data.registrar ? `Registrador: ${data.registrar}. ` : ''}${events}`.trim();
                    return { label, status: details ? 'ok' : 'fail', details: details || 'Sin datos RDAP' };
                }
                case 'emailconfig': {
                    const data = await fetchWithTimeout(`${API_BASE}/emailconfig/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const parts = [];
                    if (data.spf?.length) parts.push(`SPF: ${data.spf.join('<br>')}`);
                    if (data.dmarc?.length) parts.push(`DMARC: ${data.dmarc.join('<br>')}`);
                    if (data.dkim?.length) parts.push(`DKIM: ${data.dkim.map(d => `${d.selector}`).join(', ')}`);
                    const details = parts.join('<br>');
                    return { label, status: details ? 'ok' : 'fail', details: details || 'Sin configuración detectada' };
                }
                case 'firewall': {
                    const data = await fetchWithTimeout(`${API_BASE}/firewall/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: 'ok',
                        details: data.firewall ? `WAF: ${data.firewall}` : 'No se detectó firewall'
                    };
                }
                case 'httpsecurity': {
                    const data = await fetchWithTimeout(`${API_BASE}/httpsecurity/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const features = Object.entries(data.features || {})
                        .map(([k, v]) => `${k}: ${v ? 'sí' : 'no'}`)
                        .join(', ');
                    const ok = Object.values(data.features || {}).some(Boolean);
                    return { label, status: ok ? 'ok' : 'fail', details: features || 'Sin cabeceras de seguridad' };
                }
                case 'archive': {
                    const data = await fetchWithTimeout(`${API_BASE}/archive/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const entries = data.entries || [];
                    const details = entries
                        .slice(0, 5)
                        .map(e => `${e.timestamp} → ${e.original}`)
                        .join('<br>');
                    return { label, status: entries.length ? 'ok' : 'fail', details: details || 'Sin históricos' };
                }
                case 'globalrank': {
                    const data = await fetchWithTimeout(`${API_BASE}/globalrank/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: data.rank ? 'ok' : 'fail',
                        details: data.rank ? `Ranking Tranco: ${data.rank}` : 'No listado'
                    };
                }
                case 'block': {
                    const data = await fetchWithTimeout(`${API_BASE}/block/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const results = data.results || [];
                    const details = results
                        .map(r => `${r.resolver}: ${r.blocked ? 'bloqueado' : 'permitido'}`)
                        .join('<br>');
                    return { label, status: 'ok', details: details || 'Sin datos' };
                }
                case 'malware': {
                    const data = await fetchWithTimeout(`${API_BASE}/malware/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const status = data.data?.query_status;
                    const urls = data.data?.urls?.length || 0;
                    const isThreat = status === 'ok' && urls > 0;
                    const details = isThreat ? `Reportes: ${urls}` : 'No listado en fuentes consultadas';
                    return { label, status: isThreat ? 'fail' : 'ok', details };
                }
                case 'tlsciphers': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlsciphers/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const ciphers = data.ciphers || [];
                    return {
                        label,
                        status: ciphers.length ? 'ok' : 'fail',
                        details: ciphers.length ? ciphers.join('<br>') : 'Sin suites detectadas'
                    };
                }
                case 'tlsconfig': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlsconfig/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const protocol = data.info?.protocol || 'Desconocido';
                    const cipher = data.info?.cipher?.name || data.info?.cipher || 'N/D';
                    const ocsp = data.info?.ocsp ? 'OCSP habilitado' : 'OCSP no disponible';
                    return {
                        label,
                        status: data.status || 'ok',
                        details: `${protocol} - ${cipher} (${ocsp})`
                    };
                }
                case 'tlshandshake': {
                    const data = await fetchWithTimeout(`${API_BASE}/tlshandshake/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    const results = data.results || [];
                    const details = results
                        .map(r => `${r.label}: ${r.supported ? 'sí' : 'no'}${r.protocol ? ` (${r.protocol})` : ''}`)
                        .join('<br>');
                    return {
                        label,
                        status: results.some(r => r.supported) ? 'ok' : 'fail',
                        details: details || 'Sin datos'
                    };
                }
                case 'screenshot': {
                    const data = await fetchWithTimeout(`${API_BASE}/screenshot/${ascii}`);
                    if (data.error) return { label, status: 'error', details: data.error };
                    return {
                        label,
                        status: 'ok',
                        details: data.url ? `<a href="${data.url}" target="_blank" class="underline text-blue-600">Ver imagen</a>` : 'Sin imagen'
                    };
                }
            }
        } catch (error) {
            return { label, status: 'error', details: error.message };
        }
    }

    async function analyzeDomain(domain, selectedChecks) {
        const placeholders = createResultCard(domain, selectedChecks);
        const finalResults = {};
        const promises = selectedChecks.map(async checkType => {
            try {
                const res = await getCheckResult(checkType, domain);
                finalResults[checkType] = res;
                placeholders[checkType].innerHTML = getStatusHtml(res.status, res.details);
            } catch (err) {
                finalResults[checkType] = { label: checkConfig[checkType].label, status: 'error', details: err.message };
                placeholders[checkType].innerHTML = getStatusHtml('error', err.message);
            }
        });
        await Promise.allSettled(promises);
        return { domain, results: finalResults };
    }

    async function handleAnalysis() {
        resultsContainer.innerHTML = '';
        loader.style.display = 'flex';
        checkButton.disabled = true;
        clearMap();

        const domains = domainsInput.value.trim().split(',').map(d => d.trim()).filter(Boolean);
        const selectedChecks = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.dataset.check);

        if (!domains.length || !selectedChecks.length) {
            loader.style.display = 'none';
            checkButton.disabled = false;
            resultsContainer.innerHTML = `<div class="text-center text-gray-500 p-4">${!domains.length ? 'Introduce al menos un dominio.' : 'Selecciona al menos una verificación.'}</div>`;
            return;
        }

        const historyEntry = { date: new Date().toLocaleString(), checks: selectedChecks, domains: [] };
        const promises = domains.map(d => analyzeDomain(d, selectedChecks));
        const results = await Promise.all(promises);
        historyEntry.domains = results;
        await updateMap(domains);
        saveHistory(historyEntry);

        loader.style.display = 'none';
        checkButton.disabled = false;
    }

    historyButton.addEventListener('click', () => {
        const hidden = historyDiv.classList.toggle('hidden');
        if (!hidden) loadHistory();
    });

    clearHistoryButton.addEventListener('click', () => {
        localStorage.removeItem('domainHistory');
        loadHistory();
    });

    selectAllBtn.addEventListener('click', () => {
        checkboxes.forEach(cb => cb.checked = true);
    });

    checkButton.addEventListener('click', handleAnalysis);
</script>
</body>
</html>
